<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sender Dashboard | FikaConnect</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>   <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodVQgezGFlxyh2uGzC1b0z1m+gN42x+l92tE9k+V1+2/e+R2+b1+1g==" crossorigin=""/>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    </head>

<body>
    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>FikaConnect</h2>
            <p>Sender Dashboard</p>
        </div>
       <nav class="sidebar-nav">
                <ul>
                    <li><a href="sender-dashboard.html" class="active"><i class="fas fa-tachometer-alt"></i> Dashboard</a></li>
                    <li><a href="book-new-delivery.html"><i class="fas fa-plus-circle"></i> Book New</a></li>
                    <li><a href="sender-profile.html"><i class="fas fa-user-circle"></i> My Profile</a></li>
                    <li><a href="sender-history.html"><i class="fas fa-history"></i> My History</a></li>
                    <li><a href="settings.html"><i class="fas fa-cog"></i> Settings</a></li>
                    <li><a href="contact-us.html"><i class="fas fa-headset"></i> Contact Us</a></li>
                    <li><a href="about.html"><i class="fas fa-info-circle"></i> About Us</a></li>
                </ul>
            </nav>
        <div class="sidebar-footer">
            <a href="#" id="logoutBtnSidebar" class="logout-btn"><i class="fas fa-sign-out-alt"></i> Logout</a>
        </div>
    </aside>

    <div class="overlay" id="overlay"></div>

    <div class="main-content">
        <main class="container"> <div class="dashboard-header">
                <h2>Welcome, <span id="userNameDisplay">Sender</span>!</h2>
                <p>Your FikaConnect dashboard for managing deliveries.</p>
            </div>

            <div class="dashboard-actions">
                <a href="book-new-delivery.html" class="primary-btn"><i class="fas fa-plus-circle"></i> Book New Delivery</a>
            </div>

            <div class="dashboard-stats">
                <div class="stat-card">
                    <i class="icon fas fa-hourglass-half"></i>
                    <h3><span id="pendingDeliveriesCount">0</span></h3>
                    <p>Pending / In Progress</p>
                </div>
                <div class="stat-card">
                    <i class="icon fas fa-check-circle"></i>
                    <h3><span id="completedDeliveriesCount">0</span></h3>
                    <p>Completed Deliveries</p>
                </div>
                <div class="stat-card">
                    <i class="icon fas fa-money-bill-wave"></i>
                    <h3>UGX <span id="totalSpendAmount">0</span></h3>
                    <p>Total Spent</p>
                </div>
            </div>

            <div class="deliveries-section">
                <h3><i class="fas fa-truck-moving"></i> My Active Deliveries</h3>
                <div id="loadingDeliveries" class="loading-spinner-lg" style="display: none;">
                    <i class="fas fa-spinner fa-spin"></i> Loading Deliveries...
                </div>
                <div id="noDeliveriesMessage" class="no-deliveries-message" style="display: none;">
                    <p>You haven't booked any deliveries yet. Click "Book New Delivery" to get started!</p>
                </div>
                <div id="deliveriesList">
                    </div>
                <div id="errorMessage" class="booking-message error" style="display: none;"></div>
            </div>
        </main>

        <footer class="page-footer">
            <div class="container">
                <p>&copy; 2025 FikaConnect â€” Smart Logistics for East Africa</p>
            </div>
        </footer>
    </div>
     <script type="module">
        // Your existing Firebase imports and config
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { getFirestore, collection, query, where, orderBy, getDocs, doc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import 'https://unpkg.com/leaflet@1.7.1/dist/leaflet.js'; // Leaflet JS library

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyDq3uO76nnqqPgPaFfXpOTEnFSXRqXneWU", // Use your actual API Key
            authDomain: "fika-connect-5f844.firebaseapp.com",
            projectId: "fika-connect-5f844",
            storageBucket: "fika-connect-5f844.appspot.com",
            messagingSenderId: "124223307329",
            appId: "1:124223307329:web:76c547b91dcd25205550c0"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- DOM Elements (Updated for new sidebar elements) ---
        // const logoutBtn = document.getElementById('logoutBtn'); // Removed if only sidebar logout is used
        const logoutBtnSidebar = document.getElementById('logoutBtnSidebar'); // NEW sidebar logout
        const userNameDisplay = document.getElementById('userNameDisplay');
        const pendingDeliveriesCount = document.getElementById('pendingDeliveriesCount');
        const completedDeliveriesCount = document.getElementById('completedDeliveriesCount');
        const totalSpendAmount = document.getElementById('totalSpendAmount');
        const deliveriesList = document.getElementById('deliveriesList');
        const loadingDeliveries = document.getElementById('loadingDeliveries');
        const noDeliveriesMessage = document.getElementById('noDeliveriesMessage');
        const errorMessageDiv = document.getElementById('errorMessage');

        // NEW Sidebar DOM elements
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('overlay');

        // --- Global Variables ---
        let CURRENT_SENDER_ID = null;
        const activeTrackingMaps = {};

        // --- Event Listeners (Updated for new sidebar elements) ---
        // if (logoutBtn) { // Removed if only sidebar logout is used
        //     logoutBtn.addEventListener('click', async () => {
        //         cleanupTrackingMaps();
        //         await signOut(auth);
        //         window.location.href = 'login.html';
        //     });
        // }
        if (logoutBtnSidebar) { // NEW sidebar logout
            logoutBtnSidebar.addEventListener('click', async (e) => {
                e.preventDefault(); // Prevent default link behavior
                cleanupTrackingMaps();
                await signOut(auth);
                window.location.href = 'login.html';
            });
        }

        // NEW Sidebar Event Listeners
        if (menuToggle) {
            menuToggle.addEventListener('click', () => {
                sidebar.classList.toggle('active');
                overlay.classList.toggle('active');
            });
        }
        if (overlay) {
            overlay.addEventListener('click', () => {
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
            });
        }

        // --- Authentication State Listener ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                CURRENT_SENDER_ID = user.uid;
                try {
                    const userDocRef = doc(db, "users", user.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    if (userDocSnap.exists()) {
                        userNameDisplay.textContent = userDocSnap.data().name || "Sender";
                    } else {
                        console.warn("User document not found for:", user.uid);
                        userNameDisplay.textContent = "Sender";
                    }
                } catch (error) {
                    console.error("Error fetching user name:", error);
                    userNameDisplay.textContent = "Sender";
                }

                fetchAndDisplayDeliveries();
            } else {
                cleanupTrackingMaps();
                window.location.href = 'login.html';
            }
        });

        // --- Fetch and Display Deliveries (Your existing functions - ensure they are correct) ---
        async function fetchAndDisplayDeliveries() {
            loadingDeliveries.style.display = 'block';
            deliveriesList.innerHTML = ''; // Clear previous deliveries
            noDeliveriesMessage.style.display = 'none';
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';

            if (!CURRENT_SENDER_ID) {
                errorMessageDiv.textContent = "Error: Sender ID not available.";
                errorMessageDiv.style.display = 'block';
                loadingDeliveries.style.display = 'none';
                return;
            }

            try {
                const bookingsRef = collection(db, "bookings");
                const q = query(
                    bookingsRef,
                    where("customerId", "==", CURRENT_SENDER_ID),
                    orderBy("bookingDate", "desc")
                );

                // Use onSnapshot for real-time updates for the sender's bookings
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    let pendingCount = 0;
                    let completedCount = 0;
                    let totalSpend = 0;
                    deliveriesList.innerHTML = ''; // Clear existing cards before re-rendering

                    if (snapshot.empty) {
                        noDeliveriesMessage.style.display = 'block';
                        pendingDeliveriesCount.textContent = 0;
                        completedDeliveriesCount.textContent = 0;
                        totalSpendAmount.textContent = 0;
                        loadingDeliveries.style.display = 'none';
                        cleanupTrackingMaps(); // Clean up maps if no bookings
                        return;
                    }

                    snapshot.docs.forEach(doc => {
                        const booking = doc.data();
                        const bookingId = doc.id;

                        // Calculate stats
                        const status = booking.status ? booking.status.toLowerCase() : '';
                        if (status === 'completed' || status === 'cancelled') {
                            completedCount++;
                        } else {
                            pendingCount++;
                        }
                        if (booking.paymentStatus === 'Paid' && typeof booking.fareAmount === 'number') {
                            totalSpend += booking.fareAmount;
                        }

                        // Create and append delivery card
                        deliveriesList.appendChild(createDeliveryCard(booking, bookingId));

                        // Initialize/update map for active deliveries
                        if (booking.assignedDriver &&
                            (status !== 'completed' && status !== 'cancelled')) {
                            initializeTrackingMap(
                                bookingId,
                                booking.assignedDriver,
                                booking.pickupLocation,
                                booking.dropoffLocation
                            );
                        } else {
                            // If booking becomes completed/cancelled or unassigned, cleanup its map
                            if (activeTrackingMaps[bookingId]) {
                                activeTrackingMaps[bookingId].unsubscribe();
                                activeTrackingMaps[bookingId].map.remove();
                                delete activeTrackingMaps[bookingId];
                            }
                        }
                    });

                    pendingDeliveriesCount.textContent = pendingCount;
                    completedDeliveriesCount.textContent = completedCount;
                    totalSpendAmount.textContent = totalSpend.toLocaleString('en-UG'); // Format for Ugandan Shillings

                    loadingDeliveries.style.display = 'none';
                    noDeliveriesMessage.style.display = 'none'; // Ensure this is hidden if there are deliveries
                }, (error) => {
                    console.error("Error fetching deliveries:", error);
                    errorMessageDiv.textContent = `Error loading deliveries: ${error.message}`;
                    errorMessageDiv.style.display = 'block';
                    loadingDeliveries.style.display = 'none';
                    cleanupTrackingMaps(); // Clean up maps on error
                });

                // Store the unsubscribe function to clean up later (e.g., on logout)
                // You might want a global array for these if you have multiple onSnapshot listeners
                // For simplicity here, we assume one main listener for sender.
                // You'd need a more robust cleanup if you have multiple dynamic listeners.
                // For now, cleanupTrackingMaps will handle the map-related ones.
            } catch (error) {
                console.error("Failed to set up delivery listener:", error);
                errorMessageDiv.textContent = `Failed to set up delivery listener: ${error.message}`;
                errorMessageDiv.style.display = 'block';
                loadingDeliveries.style.display = 'none';
            }
        }

        // Re-check and ensure these helper functions are robust
        function createDeliveryCard(booking, bookingId) {
            const card = document.createElement('div');
            card.className = 'delivery-card';
            const statusClass = booking.status ? booking.status.toLowerCase().replace(/\s/g, '-') : 'pending';

            // Safely get parcel details
            const parcelType = booking.parcelDetails?.type || 'N/A';
            const parcelWeight = booking.parcelDetails?.weightKg ? `${booking.parcelDetails.weightKg} kg` : 'N/A';
            const isFragile = booking.parcelDetails?.isFragile ? 'Yes' : 'No';

            // Safely get pickup/dropoff names
            const pickupName = booking.pickupLocation?.name || 'N/A';
            const dropoffName = booking.dropoffLocation?.name || 'N/A';

            // Safely get recipient details
            const recipientName = booking.recipient?.name || 'N/A';
            const recipientContact = booking.recipient?.contact || 'N/A';

            // Safely format booking date
            let formattedBookingDate = 'N/A';
            if (booking.bookingDate && typeof booking.bookingDate.toDate === 'function') {
                formattedBookingDate = booking.bookingDate.toDate().toLocaleDateString('en-UG', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } else if (booking.bookingDate instanceof Date) {
                 formattedBookingDate = booking.bookingDate.toLocaleDateString('en-UG', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } else if (typeof booking.bookingDate === 'string') {
                try {
                    formattedBookingDate = new Date(booking.bookingDate).toLocaleDateString('en-UG', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch (e) {
                    console.warn("Could not parse bookingDate string:", booking.bookingDate);
                }
            }


            card.innerHTML = `
                <div class="delivery-card-header">
                    <h4>Booking #${bookingId.substring(0, 8)}</h4>
                    <span class="status-badge ${statusClass}">${booking.status || 'Pending'}</span>
                </div>
                <div class="delivery-details">
                    <div class="detail-item">
                        <strong>Type:</strong> <p>${booking.deliveryType === 'direct_delivery' ? 'Direct Delivery' : 'Collection Point Pickup'}</p>
                    </div>
                    <div class="detail-item">
                        <strong>Fare:</strong> <p>UGX ${typeof booking.fareAmount === 'number' ? booking.fareAmount.toLocaleString('en-UG') : 'N/A'}</p>
                    </div>
                    <div class="detail-item">
                        <strong>Pickup:</strong> <p>${pickupName}</p>
                    </div>
                    <div class="detail-item">
                        <strong>Dropoff:</strong> <p>${dropoffName}</p>
                    </div>
                    <div class="detail-item">
                        <strong>Parcel:</strong> <p>${parcelType}, ${parcelWeight}, Fragile: ${isFragile}</p>
                    </div>
                    <div class="detail-item">
                        <strong>Recipient:</strong> <p>${recipientName} (${recipientContact})</p>
                    </div>
                    <div class="detail-item">
                        <strong>Booked On:</strong> <p>${formattedBookingDate}</p>
                    </div>
                    ${booking.assignedDriver ? `<div class="detail-item"><strong>Driver:</strong> <p>${booking.assignedDriverName || 'Assigned'}</p></div>` : ''}
                </div>
                ${booking.assignedDriver && (status !== 'completed' && status !== 'cancelled') ? `<div class="delivery-map" id="map-${bookingId}"></div>` : ''}
            `;
            return card;
        }

        const driverIcon = L.icon({
            iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png', // Red marker for driver
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        const locationIcon = L.icon({
            iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', // Blue marker for locations
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });


        // Initialize tracking map logic
        async function initializeTrackingMap(bookingId, driverId, pickupLoc, dropoffLoc) {
            const mapContainer = document.getElementById(`map-${bookingId}`);
            if (!mapContainer) return;

            // If map already exists for this booking, clean it up first
            if (activeTrackingMaps[bookingId] && activeTrackingMaps[bookingId].map) {
                activeTrackingMaps[bookingId].map.remove();
                if (activeTrackingMaps[bookingId].unsubscribe) {
                    activeTrackingMaps[bookingId].unsubscribe();
                }
                delete activeTrackingMaps[bookingId];
            }

            const map = L.map(mapContainer).setView([0.3475, 32.5822], 13); // Default view, perhaps Kampala
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            activeTrackingMaps[bookingId] = { map: map, driverMarker: null, pickupMarker: null, dropoffMarker: null, unsubscribe: null };

            // Add pickup and dropoff markers
            if (pickupLoc && pickupLoc.lat && pickupLoc.lng) {
                activeTrackingMaps[bookingId].pickupMarker = L.marker([pickupLoc.lat, pickupLoc.lng], { icon: locationIcon })
                    .addTo(map)
                    .bindPopup(`Pickup: ${pickupLoc.name || 'N/A'}`);
            }
            if (dropoffLoc && dropoffLoc.lat && dropoffLoc.lng) {
                activeTrackingMaps[bookingId].dropoffMarker = L.marker([dropoffLoc.lat, dropoffLoc.lng], { icon: locationIcon })
                    .addTo(map)
                    .bindPopup(`Dropoff: ${dropoffLoc.name || 'N/A'}`);
            }

            // Adjust map bounds to fit markers
            const latLngs = [];
            if (activeTrackingMaps[bookingId].pickupMarker) latLngs.push(activeTrackingMaps[bookingId].pickupMarker.getLatLng());
            if (activeTrackingMaps[bookingId].dropoffMarker) latLngs.push(activeTrackingMaps[bookingId].dropoffMarker.getLatLng());
            if (latLngs.length > 0) {
                map.fitBounds(L.latLngBounds(latLngs).pad(0.5)); // pad adds some margin
            }


            // Listen for driver's live location
            const driverRef = doc(db, "users", driverId);
            const unsubscribe = onSnapshot(driverRef, (docSnap) => {
                if (docSnap.exists()) {
                    const driverData = docSnap.data();
                    const driverLocation = driverData.lastKnownLocation;

                    if (driverLocation && driverLocation.lat && driverLocation.lng) {
                        const driverLatLng = L.latLng(driverLocation.lat, driverLocation.lng);
                        if (activeTrackingMaps[bookingId].driverMarker) {
                            activeTrackingMaps[bookingId].driverMarker.setLatLng(driverLatLng);
                        } else {
                            activeTrackingMaps[bookingId].driverMarker = L.marker(driverLatLng, { icon: driverIcon })
                                .addTo(map)
                                .bindPopup(`Driver: ${driverData.name || 'N/A'}`)
                                .openPopup();
                        }
                        // Optional: Center map on driver if they are moving significantly
                        // map.setView(driverLatLng, map.getZoom());
                    } else {
                        // If driver has no location, remove marker
                        if (activeTrackingMaps[bookingId].driverMarker) {
                            map.removeLayer(activeTrackingMaps[bookingId].driverMarker);
                            activeTrackingMaps[bookingId].driverMarker = null;
                        }
                    }
                } else {
                    console.log(`Driver document for ID ${driverId} does not exist.`);
                    // If driver document is gone, cleanup map and marker for this booking
                    if (activeTrackingMaps[bookingId].driverMarker) {
                        map.removeLayer(activeTrackingMaps[bookingId].driverMarker);
                    
activeTrackingMaps[bookingId].driverMarker = null;
                    }
                    if (activeTrackingMaps[bookingId].unsubscribe) {
                         activeTrackingMaps[bookingId].unsubscribe();
                         activeTrackingMaps[bookingId].unsubscribe = null;
                    }
                }
            }, (error) => {
                console.error("Error listening to driver location:", error);
            });

            activeTrackingMaps[bookingId].unsubscribe = unsubscribe;
        }

        // NEW: Function to clean up all active map instances and their listeners
        function cleanupTrackingMaps() {
            for (const bookingId in activeTrackingMaps) {
                if (activeTrackingMaps[bookingId].unsubscribe) {
                    activeTrackingMaps[bookingId].unsubscribe(); // Unsubscribe from Firestore listener
                }
                if (activeTrackingMaps[bookingId].map) {
                    activeTrackingMaps[bookingId].map.remove(); // Remove Leaflet map instance
                }
                delete activeTrackingMaps[bookingId];
            }
            console.log("Cleaned up all active tracking maps.");
        }

        // Call cleanup on page unload to prevent memory leaks and unnecessary listeners
        window.addEventListener('beforeunload', cleanupTrackingMaps)
    ;

    
    </script>
</body>
</html>